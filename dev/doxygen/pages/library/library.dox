/**

    @page library_documentation Library Documentation

    @tableofcontents
    
    @warning    Die hier beschriebenen Dinge sind keineswegs in Stein gemeisselt, es kann sich noch vieles verändern.
                Teilweise handelt es sich auch mehr um spontane Ideen, die noch weiter verfolgt werden sollten.
                Es ist gut möglich, dass einige dieser Ideen sich als nicht nützlich erweisen und dadurch wieder entfernt werden.
                Sie sind vorläufig einfach hier in der Doku festgehalten, damit sie nicht vergessen gehen.

    This is the documentation of an EDA4U library and all their specifications.
    
    Die Bauteilebibliothek ist ein extrem wichtiger Bestandteil von EDA4U.
    Es wird sehr viel Wert auf eine gut strukturierte Bibliothek gelegt.
    Daher hier eine ausführliche Beschreibung zum Prinzip.

    
    
    
    @section library_misc General Information
    
        - UUID: https://de.wikipedia.org/wiki/Universally_Unique_Identifier
        - The whole library is stored in the EDA4U's "lib/" directory. 
          There is always a local repository in the directory "lib/local/",
          and in "lib/repositories/" are the libraries which are downloaded and will be updated automatically over the internet.
        - Each library element (symbol, footprint, ...) ist stored in a separate directory. These directories can contain files and subdirectories.
        - Each library element (symbol, footprint, ...) has a unique UUID. So a Symbol from repository A can be combined with a footprint from repository B, 
          because their UUID will guarantee that only the right elements will be combined, and not the wrong ones.
          @warning  The UUIDs of all elements must be unique, so a footprint mustn't have the same UUID as a symbol (for example)!
                    This, because all library elements are in the same namespace.
        - For better performance of the library (searching in filesystem can be quite slow...), we use a SQLite database for caching.
          With a "read library"-function, the SQLite database will be filled with all important data of the library and their elements. This can take some time.
          Searching for elements will now be done with a SELECT statement in the database, which is very fast. 
          To load a searched element, there's the filepath of the elment stored in the database. So the elements themselves are not stored completely in the database!
          With a MD5 checksum compare, it's possible to make the next "read library"-action faster, because we can detect if a file has changed or not.


    @section file_structure File Structure
    
        Die gesamte Bibliothek befindet sich im Workspace im Unterordner "lib". Die Ordnerstruktur ist wie folgt:
@code
        +- lib
            |
            +- local
            |   |
            |   +- component_categories
            |   +- package_categories
            |   +- symbols
            |   +- components
            |   +- component_symbols
            |   +- footprints
            |   +- generic_components
            |   +- models
            |   +- packages
            |
            +- repositories
                |
                +- {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
                    |
                    +- component_categories
                    |   |
                    |   +- {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
                    |       |
                    |       +- component_category.xml
                    |       +- image.png
                    |
                    +- package_categories
                    |   |
                    |   +- {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
                    |       |
                    |       +- package_category.xml
                    |       +- image.png
                    |
                    +- symbols
                    |   |
                    |   +- {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
                    |       |
                    |       +- symbol.xml
                    |       +- image.png
                    |
                    +- components
                    |   |
                    |   +- {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
                    |       |
                    |       +- component.xml
                    |       +- image.png
                    |
                    +- component_symbols
                    |   |
                    |   +- {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
                    |       |
                    |       +- component_symbol.xml
                    |       +- image.png
                    |
                    +- footprints
                    |   |
                    |   +- {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
                    |       |
                    |       +- footprint.xml
                    |       +- image.png
                    |
                    +- generic_components
                    |   |
                    |   +- {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
                    |       |
                    |       +- generic_component.xml
                    |       +- image.png
                    |
                    +- models
                    |   |
                    |   +- {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
                    |       |
                    |       +- model.xml
                    |       +- image.png
                    |
                    +- packages
                    |   |
                    |   +- {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
                    |       |
                    |       +- package.xml
                    |       +- image.png
                    |
                    +- image.png
                    +- repository.xml
@endcode

        Erläurerungen:
            - local/            Alle lokalen Elemente (vom Benutzer selbst angelegt oder importiert)
            - repositories/     Alle Elemente, welche aus Repositories heruntergeladen wurden
            
    
    @section library_sec1 Anbindung an Lagerverwaltungssysteme

        Für eine Anbindung der Bauteile in der Bibliothek an ein Lagerverwaltungssystem kommt eine separate
        Datenbank zum Einsatz, in der Bauteilebibliothek werden keinerlei Bestellnummern oder Preise abgelegt.
        Es ist geplant, dass für jedes Lagerverwaltungssystem ein eigenes Plugin angeboten wird. Jedes dieser
        Plugins benutzt dann seine eigene Bibliothek (SQLite3) um z.B. Lieferanten, Bestellnummern, Preise, 
        Lagerbestände usw. abzuspeichern.


    @section library_sec2 Repositories & Updates

        Zum aktualisieren von Elementen (Symbole, Footprints, ...) werden Repositories verwendet. Es wird
        offizielle Repositories von EDA4U geben, aber auch Drittanbieter können eigene Repositories 
        erstellen. Wird der eigenen Bibliothek ein Repository hinzugefügt, so werden alle darin enthaltenen
        Elemente heruntergeladen und von diesem Zeitpunkt an automatisch mit Updates versorgt. Wenn der
        Anbieter neue Elemente in sein Repository lädt, werden diese beim nächsten Update automatisch
        der eigenen Bibliothek hinzugefügt. Löscht man ein Repository, werden auch alle Dateien davon
        gelöscht. Existieren jedoch in der eigenen Bibliothek noch Links auf Elemente, die gelöscht
        werden sollen, werden die verlinkten Elemente zuerst der eigenen Bibliothek hinzugefügt.

        Jedes Repository muss alle Elemente, die von den darin enthaltenen Elementen gebraucht werden, selbst
        enthalten. Es darf keine Verknüpfungen zu Elementen geben, die nicht im Repository enthalten sind.
        Einzige Ausnahme stellen die offiziellen EDA4U Repositories für Basiselemente dar. Diese
        dürfen vorausgesetzt werden, müssen aber auch dementsprechend deklariert sein, damit ein Deaktivieren
        eines Basis-Repositories verhindert wird wenn ein fremdes, aktives Repository dieses voraussetzt.

        Enthält ein Repository veraltete Elemente, die der Benutzer von einem anderen Repository in einer
        neueren Version zur Verfügung hat, wird automatisch die neuere Version verwendet. So kommt der
        Benutzer auch in den Genuss von aktuellen Elementen, auch wenn der Anbieter eines Repositories seine
        zur Verfügung gestellten Elemente nicht pflegt (aktualisiert).

        Von EDA4U werden folgende Repositories offiziell zur Verfügung gestellt:
            - EDA4U Base Symbols (nur Schaltplansymbole; R, C, L, LED, Zeichungsrahmen usw.)
            - EDA4U Base Packages (Footprints und 3D-Modelle; R/C/L-Gehäuse, DIP, TQFP usw.)
            - EDA4U Base Components (Nur Verknüpfungen zwischen Symbolen und Gehäusen; R, C, L, LED usw.)
            - EDA4U Electronics (Mikrocontroller, Displays, Pegelwandler, Treiber, .......)
                - Mit Abhängigkeiten zu allen dreien "EDA4U Base" Repositories
            - EDA4U Automation (Für Stromlaufpläne [nur Symbole, keine Footprints]; SPS, Schütze, LS, FI usw.)
                - Mit Abhängigkeit zu "EDA4U Base Symbols"

        Editiert der Benutzer ein Element aus einem Repository, so wird automatisch eine Kopie des Elementes
        angelegt, das keinen Link mehr zum Repository hat. Das originale Element bleibt unangetastet.
        Elemente ohne Link zu einem Repository werden den Elementen mit Link zu einem Repository immer vorgezogen.
        Damit wird sichergestellt, dass immer das Element verwendet wird, das vom Benutzer manuell bearbeitet wurde.

        Bei Updates werden die alten Elemente immer in der Datenbank liegengelassen. So können später auch mal
        ältere Versionen von Elementen erzwungen werden, falls es bei neueren Versionen zu Problemen kommt.


    @section library_sec3 Feedbacksystem

        Innerhalb eines Repositories wird es ein Feedbacksystem geben, um fehlerhafte Elemente melden
        zu können. So kann der Betreiber eines Repositories Fehler sehr schnell korrigieren.
        Gemeldete Fehler sollen auch für alle anderen Benutzer sichtbar sein, und im Bibliotheks-Browser
        sollen bei den entsprechenden Elementen kleine Warnhinweise erscheinen. Allerdings dürfen nur
        Meldungen angezeigt werden, die für die aktuell installierte Version des entsprechenden Elementes
        gelten. Wird das fehlerhafte Element auf eine neuere Version aktualisiert, so müssen die Warnhinweise
        unbedingt verschwinden (nicht gelöscht werden, nur ausgeblendet).


    @section library_sec4 Kennzeichnung von Elementen (UUID)

        Alle Symbole, Footprints usw. bekommen beim Erstellen eine weltweit eindeutige Kennung, eine UUID.
        Diese UUID wird dann zum Referenzieren zwischen verschiedenen Elementen verwendet. Ein Bauteil A
        verwendet z.B. das Symbol mit der UUID 12345 und den Footprint mit der UUID 55555. In welchem 
        Repository diese Elemente zur Verfügung gestellt werden, spielt keine Rolle. So lassen sich problemlos 
        Symbole aus einem Repository mit Footprints aus einem anderen Repository kombinieren.

        Neben der UUID hat jedes Element auch eine Versionsbezeichnung. Anhand dieser Nummer ermittelt der Update-
        Mechanismus, ob der Benutzer die aktuellste Version hat, oder ob das Element aktualisiert werden muss.
        Die Versionsbezeichnung ist ein String der Form "2.1.5" mit mindestens einer, bis unendlich vielen Zahlen.
        Der Ersteller eines Elementes vergibt jeweils nur eine Zahl, z.B. Version "1", "2" oder "100".
        Ein Fork davon hängt dann eine zusätzliche Nummer an, getrennt mit einem Punkt: "1.1", "2.1" oder "100.1".
        Aktualisiert der Forker seine Version, darf er nur "seine" Nummer verändern: "1.2", "2.2" oder "100.2".
        Jeder weitere Fork hängt dann eine Nummer mehr an. Der Update-Mechanismus bewertet dann die Versions-
        bezeichnung folgendermassen:

        (niedrigste bis höchste Priorität, also zuerst die älteste und am Schluss die neuste Version)
        1 --> 2 --> 2.1 --> 2.1.1 --> 2.1.2 --> 2.1.2.999.6.70.1 --> 2.5 --> 3 --> 3.1 usw.


    @section library_sec5 Digitale Signatur von Elementen

        Eventuell macht es Sinn, offizielle EDA4U Elemente mit einer digitalen Signatur zu versehen.
        Damit sind diese Elemente quasi als "vertrauenswürdig" gekennzeichnet und können gut von Elementen
        von Drittanbietern unterschieden werden. Signierte Elemente sollen dann im Bibliotheksbrowser auch
        besonders hervorgehoben werden.

        Dazu würde sich eine zusätzliche Spalte "signature" für jedes Element anbieten. Bei nicht signierten
        Elementen steht hier NULL drin. Bei signierten Elementen liegt die UUID mit angehängter Versionsnummer
        in verschlüsselter Form in diesem Feld. Die Verschlüsselung wird mit einem privaten Schlüssel (den nur
        U.B. besitzt!) durchgeführt, und mit dem öffentlichen Schlüssel, der in EDA4U einkompiliert ist,
        wieder entschlüsselt.


    @section library_sec6 Struktur von Elementen

        Für jeden Element-Typ (Symbole, Footprints, Komponenten, ...) wird eine separate Tabelle in der Datenbank
        verwendet. Als Primärschlüssel wird nicht die UUID, sondern eine automatische, inkrementierende ID
        benutzt. Die UUID ist aber auch als einzigartig definiert und darf daher in jeder Tabelle nur einmal 
        vorkommen. Statische Eigenschaften (Eigenschaften, die für jedes Element in gleicher Anzahl benötigt 
        werden), werden direkt in dafür vorgesehenen Spalten abgelegt. Dynamische Eigenschaften (z.B. die Pins
        eines Symbols, die grafische Beschreibung von Symbolen und Footprints usw.) werden in separaten Tabellen 
        (z.B. "symbol_blobs") in einer Blob-Spalte unkomprimiert als XML-Dateien abgelegt.


    @section library_sec7 Kategorisierung von Elementen

        Alle Elemente werden in Kategorien eingeteilt. Dabei gibt es zwei verschiedene Sortimente von Kategorien.
        Ein Sortiment wird für die Symbole und Komponenten verwendet (z.B. Widerstände, Kondensatoren, ...).
        Das andere Sortiment wird für die Footprints, 3D-Modelle und Gehäuse verwendet (z.B. DIP, TQFP, ...).

        Eventuell würde aber auch ein Sortiment genügen?!

        Wie die Elemente, bekommen auch die Kategorien jeweils eine UUID. mit der sie identifiziert werden können.
        In Repositories können auch neue Kategorien vorhanden sein, die dann ebenfalls in der Datenbank des
        Benutzers installiert werden.


    @section library_sec8 Lokalisierung (Sprachen, Übersetzungen)

        Für alle Elemente und Kategorien müssen englische Namen und Beschreibungen verfügbar sein. Zusätzlich
        können (optional) weitere Sprachen (am besten unbeschränkt viele, also dynamisch) definiert werden können.
        Beim Aktualisieren von Elementen aus dem Repository sollen auch die Namen und Beschreibungen jeweils
        aktualisiert werden. So kann man die Unterstützung für verschiedene Sprachen nach und nach ausbauen und
        über Updates den Benutzern zur Verfügung stellen.

        Für jede Sprache soll eine eigene Tabellenspalte existieren, die dynamisch erstellt werden kann.
        Von Anfang an werden die Spalten für die Sprachen Englisch, Deutsch und Französisch angeboten.
        Die Englische Bezeichnung muss für jedes Element zwingend vorhanden sein, die Übersetzungen in alle anderen
        Sprachen sind optional. Für nicht vorhandene Übersetzungen wird NULL in die Datenbank geschrieben, damit
        automatisch die englische Bezeichnung verwendet wird, auch wenn man das Programm z.B. auf Deutsch benutzt.

        Bei Kategorien wird genau das gleiche Verfahren angewendet.

        Optional kann man in den Programmeinstellungen später mal die Reihenfolge der Sprachen wählen.
        Also z.B. 1. Priorität Deutsch, 2. Priorität Französisch und 3. Priorität Englisch. Ist die deutsche
        Bezeichnung eines Elementes vorhanden, wird diese angezeigt. Falls nicht, wird die französische Bezeichnung
        angezeigt, und wenn diese auch fehlt wird die englische Bezeichnung verwendet.


    @section library_sec9 Import / Export von Elementen

        Für den einfachen (Bibliotheks-)Datenaustausch ohne Repositories wird es eine Import/Export-Funktion geben.
        Diese erlaubt es, Elemente aus der eigenen Bibliothek zu exportieren, damit man sie in einer anderen
        Bibliothek wieder Importieren kann. Beim Export werden alle relevanten Daten (auch Beschreibungen in allen
        verfügbaren Sprachen) in XML-Dateien geschrieben, für jedes Element gibt es eine eigene XML-Datei.
        Die XML-Dateien werden dann in einem Archiv (z.B. tar.gz) zusammengefasst, auch wenn nur ein einziges Element
        exportiert wird. Beim Import wird dann das Archiv extrahiert und alle darin befindlichen Elemente zur
        Bibliothek hinzugefügt.

*/
